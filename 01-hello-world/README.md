# 01-hello-world

Contains a simple example of using a language model to generate text.

## Libraries Involved

- `github.com/testcontainers/testcontainers-go`: [Testcontainers for Golang](https://github.com/testcontainers/testcontainers-go) is library for running Docker containers for integration tests.
- `github.com/testcontainers/testcontainers-go/modules/ollama`: A module for running Ollama language models using Testcontainers.
- `github.com/tmc/langchaingo`: A library for interacting with language models.
- `github.com/tmc/langchaingo/llms/ollama`: A specific implementation of the language model interface for Ollama.

## Code Explanation

The code in `main.go` sets up and runs a containerized Ollama language model using Testcontainers, then uses the model to generate text based on a given prompt.

### Main Functions

- `main()`: The entry point of the application. It calls the `run()` function and logs any errors.
- `run()`: The main logic of the application. It performs the following steps:
  1. Runs an Ollama container using Testcontainers. The image used is `mdelapenya/llama3.2:0.5.4-1b`, loading the `llama3.2:1b` model.
  2. Retrieves the connection string for the running container.
  3. Creates a new Ollama language model instance.
  4. Defines the content to be generated by the language model.
  5. Generates the content and prints it to the console.

## Running the Example

To run the example, navigate to the `01-hello-world` directory and run the following command:

```sh
go run .
```

The application will start a containerized Ollama language model and generate text based on the provided prompt. The generated text will be displayed in the console.

```shell
Here are three short bullet points explaining why Go is awesome:

• **Concise and Efficient**: Go's syntax and design make it one of the most concise and efficient programming languages, allowing developers to write code that is both elegant and performant.

• **Goroutines and Channels**: Go's built-in concurrency features, such as goroutines and channels, enable developers to write scalable and concurrent systems with ease, making it a popular choice for cloud-native applications.

• **Lack of Garbage Collection**: Go's focus on memory management through its ownership system and garbage collection mechanism allows developers to write low-level, performance-critical code that is free from the overhead of traditional garbage collectors.%
```
